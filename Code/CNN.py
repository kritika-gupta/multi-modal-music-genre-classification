import matplotlib.pyplot as plt
import librosa
import librosa.display
import IPython.display
import numpy as np
from numpy import argmax
import pandas as pd
import random
import torch
import torch.nn as nn 
import torch.optim as optim
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from torchsummary import summary


############## data loading for pretraining (with augmentations)
# from utils import load_data_withaug
# zipped_data, genre_list = load_data_withaug()



############## custom data loader

class CustomDataset(Dataset):
    def __init__(self, split):
        self.input, self.target = zip(*split)
        
        self.melspec, self.lyrics = zip(*self.input)
        self.melspec = torch.from_numpy(np.array([x.reshape( (1, 128, 431) ) for x in self.melspec]))    
        self.target = torch.tensor(self.target)
        
    def __getitem__(self, index):
        
        #melspec, lyric data-pair
        data_pair = (self.melspec[index], self.lyrics[index])
        label = self.target[index]
        return data_pair, label

    def __len__(self):
        count = len(self.target)
        return count 



############## CNN model 

class CNN(nn.Module):
    
    def __init__(self, num_classes):
        super(CNN, self).__init__()

        self.avgpool = nn.AvgPool2d(2, stride=2)
        
        self.conv1 = nn.Conv2d(in_channels=1, out_channels=24, kernel_size=5, stride =1 )
        self.conv2 = nn.Conv2d(in_channels=24, out_channels=48, kernel_size=5, stride =1, padding = 'same' )
        self.conv3 = nn.Conv2d(in_channels=48, out_channels=48, kernel_size=5, stride =1, padding = 'same' )

    
        self.dropout1 = nn.Dropout(0.5)
        self.linear1 = nn.Linear(38160, 64)
        self.dropout2 = nn.Dropout(0.5)
        
        self.linear2 = nn.Linear(64, num_classes)
        
    def forward(self, x):
        
        out = nn.functional.relu(self.avgpool(self.conv1(x)))
        out = nn.functional.relu(self.avgpool(self.conv2(out)))
        out = nn.functional.relu(self.avgpool(self.conv3(out)))
        out = torch.flatten(out, start_dim = 1)
        

        out = self.dropout1(out) 

        out = nn.functional.relu(self.linear1(out))
        out = self.dropout2(out)

        out = self.linear2(out)

        return out

def main():
  ############## normal data loading 
  #%cd /content/drive/MyDrive/multi-modal-music-genre-classification/
  from utils import load_data

  zipped_data, genre_list = load_data()
  NUM_CLASSES = len(genre_list)
  print(NUM_CLASSES)
  print(len(zipped_data))



  ############## data separation 

  dataset = zipped_data
  random.shuffle(dataset)
  n = len(dataset)
  print(n)

  #train val test split 8:1:1
  train = dataset[0:int(0.8*n)]
  val = dataset[int(0.8*n):int(0.9*n)]
  test = dataset[int(0.9*n):]

  trainDataset = CustomDataset(train)
  valDataset = CustomDataset(val)
  testDataset = CustomDataset(test)

  trainLoader = DataLoader(trainDataset, batch_size=32)
  valLoader = DataLoader(valDataset, batch_size=32)
  testLoader = DataLoader(testDataset)



  ############## load model

  model = CNN(num_classes = NUM_CLASSES)
  model = model.float()

  # Transfer Model to GPU if available
  if torch.cuda.is_available():
      model = model.cuda()

  summary(model, (1, 128, 431))


  ############## training parameters

  batch_size = 64
  epochs = 40
  criterion = nn.CrossEntropyLoss()
  optimizer = optim.Adam(model.parameters(), lr = 0.0001)

  #min_valid_loss = np.inf

  # iterate through all the epochs
  for epoch in range(epochs):
      # go through all the batches generated by dataloader

      ############## train loop
      train_loss = 0.0
      for i, data in enumerate(trainLoader):

              (inputs, targets) = data
              inputs = inputs[0]

              # Transfer Data to GPU if available
              if torch.cuda.is_available():
                  inputs, targets = inputs.cuda(), targets.cuda()

              optimizer.zero_grad()
              outputs = model(inputs.float())
              # calculate loss
              loss = criterion(outputs, targets)
              # credit assignment
              loss.backward()
              # update model weights
              optimizer.step()

              train_loss += loss.item()
      
      ############## validation loop
      model.eval()
      valid_loss = 0.0 
      for i, data in enumerate(valLoader):

        (inputs, targets) = data
        inputs = inputs[0]

        if torch.cuda.is_available():
            inputs, targets = inputs.cuda(), targets.cuda()
        
        outputs = model(inputs.float())
        loss = criterion(outputs,targets)
        valid_loss += loss.item() 
      

      print(f'Epoch {epoch+1} \t\t Training Loss: {train_loss / len(trainLoader)} \t\t Validation Loss: {valid_loss / len(valLoader)}')
      
      # if min_valid_loss > valid_loss:
      #     print(f'Validation Loss Decreased({min_valid_loss:.6f}--->{valid_loss:.6f}) \t Saving The Model')
      #     min_valid_loss = valid_loss
          
      #     # Saving State Dict
      torch.save(model.state_dict(), '/content/drive/MyDrive/multi-modal-music-genre-classification/CNN_pytorch_training/saved_model.pth')


  ############## test loop
  test_loss = 0.0
  total = 0.0
  num_correct = 0.0

  # loop over all batches in test set
  for i, data in enumerate(testLoader):

      (inputs, targets) = data
      inputs = inputs[0]

      # Transfer Data to GPU if available
      if torch.cuda.is_available():
          inputs, targets = inputs.cuda(), targets.cuda()
      
      outputs = model(inputs.float()) 
      res = torch.argmax(outputs, 1)

      # print(res.item(), targets.item())

      num_correct += (res.item() == targets.item())
      total += targets.size(0)
      test_loss += criterion(outputs, targets).item()
      

  print(f"Test Accuracy of the model: {float(num_correct)/float(total)*100:.2f}")

if __name__ == "__main__":
   # stuff only to run when not called via 'import' here
   main()
